// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

/**
 * @title IGroth16Verifier
 * @notice Interface for the snarkjs-generated Groth16 verifier contract.
 *         The actual Groth16Verifier.sol is auto-generated by:
 *         npx snarkjs zkey export solidityverifier circuits/build/price_commitment_final.zkey src/Groth16Verifier.sol
 */
interface IGroth16Verifier {
    function verifyProof(
        uint[2]  calldata a,
        uint[2][2] calldata b,
        uint[2]  calldata c,
        uint[3]  calldata input  // [commitment, price, timestamp]
    ) external view returns (bool);
}

/**
 * @title VerisOracleV2
 * @notice Veris price oracle with REAL Groth16 ZK proof verification.
 *
 * Upgrade from V1:
 *   V1: submitPrice(price, timestamp, keccak_commitment)
 *       → commit-reveal scheme, no actual ZK
 *
 *   V2: submitPriceWithProof(price, timestamp, commitment, proof_a, proof_b, proof_c)
 *       → verifies Groth16 proof on-chain via Groth16Verifier.sol
 *       → proves: "agent knows secret salt such that Poseidon(price,ts,salt)=commitment"
 *       → salt is NEVER revealed — this is genuine zero knowledge
 *
 * Circuit: circuits/price_commitment.circom
 * Hash:    Poseidon(3) — ZK-friendly, 240 constraints vs 28,000 for keccak256
 * Curve:   BN128 (same as Ethereum's ecpairing precompile)
 *
 * @dev Deploy Groth16Verifier.sol first, pass its address to constructor.
 */
contract VerisOracleV2 {

    // ── State ────────────────────────────────────────────────────────────

    address public owner;
    address public authorizedSubmitter;
    IGroth16Verifier public verifier;   // ← The snarkjs-generated contract

    struct PriceRecord {
        uint256 price;        // BNB/USD × 1e8
        uint256 timestamp;
        bytes32 commitment;   // Poseidon(price, timestamp, salt) — on-chain commitment
        bool    verified;     // true only if Groth16 proof checked out
        bool    zkVerified;   // true = real ZK proof, false = legacy commit-reveal
    }

    PriceRecord public latestPrice;

    // History of proofs — for Greenfield audit trail references
    struct ProofRecord {
        uint256 price;
        uint256 timestamp;
        bytes32 commitment;
        bytes32 greenfieldObjectId; // BNB Greenfield object storing full proof
    }

    ProofRecord[] public priceHistory;

    mapping(address => bool) public freeCallers;

    uint256 public constant QUERY_FEE    = 0.001 ether;
    uint256 public constant MAX_STALENESS = 1 hours;

    // ── Events ───────────────────────────────────────────────────────────

    event PriceUpdatedZK(
        uint256 price,
        uint256 timestamp,
        bytes32 commitment,
        bool    zkVerified,
        bytes32 greenfieldRef
    );
    event QueryFeeCollected(address caller, uint256 fee);
    event VerifierUpdated(address oldVerifier, address newVerifier);

    // ── Errors ───────────────────────────────────────────────────────────

    error NotOwner();
    error NotAuthorizedSubmitter();
    error InvalidZKProof();
    error PriceStale();
    error InsufficientQueryFee();
    error ZeroAddress();
    error TimestampNotFresh();
    error PriceOutOfBounds();

    // ── Constructor ──────────────────────────────────────────────────────

    /**
     * @param _submitter   Authorized off-chain agent wallet
     * @param _verifier    Groth16Verifier contract (from snarkjs export)
     */
    constructor(address _submitter, address _verifier) {
        if (_submitter == address(0)) revert ZeroAddress();
        if (_verifier  == address(0)) revert ZeroAddress();
        owner               = msg.sender;
        authorizedSubmitter = _submitter;
        verifier            = IGroth16Verifier(_verifier);
    }

    modifier onlyOwner()     { if (msg.sender != owner)               revert NotOwner();               _; }
    modifier onlySubmitter() { if (msg.sender != authorizedSubmitter) revert NotAuthorizedSubmitter(); _; }

    // ── Core: Submit with REAL ZK proof ──────────────────────────────────

    /**
     * @notice Submit a price update with a Groth16 ZK proof.
     *
     * The proof proves: "I know a secret `salt` such that
     *                    Poseidon(price, timestamp, salt) = commitment"
     *
     * This is verified ON-CHAIN by the Groth16Verifier contract.
     * If the proof is invalid, the transaction reverts.
     *
     * @param price            BNB/USD × 1e8
     * @param timestamp        Unix timestamp of the price fetch
     * @param commitment       Poseidon(price, timestamp, salt) — public output of circuit
     * @param proof_a          Groth16 proof component A
     * @param proof_b          Groth16 proof component B
     * @param proof_c          Groth16 proof component C
     * @param greenfieldRef    BNB Greenfield object ID where full proof is stored
     *
     * Public signals layout expected by verifier: [commitment, price, timestamp]
     */
    function submitPriceWithProof(
        uint256      price,
        uint256      timestamp,
        bytes32      commitment,
        uint[2]      calldata proof_a,
        uint[2][2]   calldata proof_b,
        uint[2]      calldata proof_c,
        bytes32      greenfieldRef
    ) external onlySubmitter {

        // ── Sanity checks ────────────────────────────────────────────────
        if (timestamp > block.timestamp)                 revert TimestampNotFresh();
        if (block.timestamp - timestamp > 5 minutes)     revert TimestampNotFresh();
        if (price < 10 * 1e8 || price > 100_000 * 1e8) revert PriceOutOfBounds();

        // ── ON-CHAIN ZK PROOF VERIFICATION ──────────────────────────────
        // This is the real thing. The Groth16Verifier contract checks the
        // elliptic curve pairings. If proof is fabricated, this reverts.
        //
        // Public inputs: [commitment, price, timestamp]
        // commitment is uint256 (Poseidon output fits in a field element)
        uint[3] memory publicSignals = [
            uint256(commitment),   // Poseidon output
            price,                 // public input
            timestamp              // public input
        ];

        bool valid = verifier.verifyProof(proof_a, proof_b, proof_c, publicSignals);
        if (!valid) revert InvalidZKProof();

        // ── Store verified price ─────────────────────────────────────────
        latestPrice = PriceRecord({
            price:      price,
            timestamp:  timestamp,
            commitment: commitment,
            verified:   true,
            zkVerified: true   // ← This is a REAL ZK-verified price
        });

        priceHistory.push(ProofRecord({
            price:             price,
            timestamp:         timestamp,
            commitment:        commitment,
            greenfieldObjectId: greenfieldRef
        }));

        emit PriceUpdatedZK(price, timestamp, commitment, true, greenfieldRef);
    }

    /**
     * @notice Legacy submit (commit-reveal only, no ZK).
     *         Kept for backward compatibility with V1 oracle agent.
     *         Does NOT use Groth16 — zkVerified will be false.
     */
    function submitPrice(
        uint256 price,
        uint256 timestamp,
        bytes32 commitment
    ) external onlySubmitter {
        if (timestamp > block.timestamp)                 revert TimestampNotFresh();
        if (block.timestamp - timestamp > 5 minutes)     revert TimestampNotFresh();
        if (price < 10 * 1e8 || price > 100_000 * 1e8) revert PriceOutOfBounds();

        latestPrice = PriceRecord({
            price:      price,
            timestamp:  timestamp,
            commitment: commitment,
            verified:   true,
            zkVerified: false  // ← Legacy — no ZK
        });

        emit PriceUpdatedZK(price, timestamp, commitment, false, bytes32(0));
    }

    // ── Read price ───────────────────────────────────────────────────────

    function getPrice() external payable returns (uint256 price, uint256 timestamp, bool zkVerified) {
        if (block.timestamp - latestPrice.timestamp > MAX_STALENESS) revert PriceStale();
        if (!latestPrice.verified) revert PriceStale();

        if (!freeCallers[msg.sender]) {
            if (msg.value < QUERY_FEE) revert InsufficientQueryFee();
            emit QueryFeeCollected(msg.sender, msg.value);
        }

        return (latestPrice.price, latestPrice.timestamp, latestPrice.zkVerified);
    }

    function getPriceUnsafe() external view returns (
        uint256 price, uint256 timestamp, bool fresh, bool zkVerified
    ) {
        bool isFresh = (block.timestamp - latestPrice.timestamp) <= MAX_STALENESS;
        return (latestPrice.price, latestPrice.timestamp, isFresh, latestPrice.zkVerified);
    }

    // ── Admin ────────────────────────────────────────────────────────────

    function addFreeCaller(address caller)    external onlyOwner { freeCallers[caller] = true; }
    function setSubmitter(address _submitter) external onlyOwner { authorizedSubmitter = _submitter; }

    function updateVerifier(address _verifier) external onlyOwner {
        emit VerifierUpdated(address(verifier), _verifier);
        verifier = IGroth16Verifier(_verifier);
    }

    function withdrawFees()                    external onlyOwner { payable(owner).transfer(address(this).balance); }
    function transferOwnership(address newOwner) external onlyOwner { owner = newOwner; }

    function getHistoryLength() external view returns (uint256) { return priceHistory.length; }

    receive() external payable {}
}
